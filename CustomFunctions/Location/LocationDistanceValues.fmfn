/*******************************************************************************
 * LocationDistanceValues ( startLatitude ; startLongitude ; endLatitude ; endLongitude )
 *
 * This function calculates based on a spherical approximation of the surface of
 * the Earth.
 *
 * @parameter startLatitude: Latitude of the first point, in degrees
 * @parameter startLongitude: Longitude of the first point, in degrees
 * @parameter endLatitude: Latitude of the second point, in degrees
 * @parameter endLongitude: Longitude of the first point, in degrees
 *
 * @return A return-delimited list of data about the path between two points on
 * the surface of the Earth:
 *		1. distance in meters between the two points
 *		2. initial bearing starting from the start point towards the end point
 *		3. final forward bearing at the end point
 *
 * @history 2013-09-02 - Jeremy Bante <http://scr.im/jbante> - Created
 *
 * @see http://en.wikipedia.org/wiki/Haversine_formula
 ******************************************************************************/

Let ( [
	// precompute values used in formulas more than once
	_longitudeDifference = Radians ( endLongitude - startLongitude ) ;
	_cosLatitudeDifference = Cos ( Radians ( endLatitude - startLatitude ) ) ;
	_cosLongitudeDifference = Cos ( _longitudeDifference ) ;
	_startLatitude = Radians ( startLatitude ) ;
	_startLongitude = Radians ( startLongitude ) ;
	_endLatitude = Radians ( endLatitude ) ;
	_endLongitude = Radians ( endLongitude ) ;
	_cosStartLatitude = Cos ( _startLatitude ) ;
	_cosEndLatitude = Cos ( _endLatitude ) ;
	_sinStartLatitude = Sin ( _startLatitude ) ;
	_sinEndLatitude = Sin ( _endLatitude ) ;

	_distance =
		6374447	// average radius in meters
		* Acos (
			_cosLatitudeDifference
			- _cosStartLatitude
			* _cosEndLatitude
			* ( 1 - _cosLongitudeDifference )
		) ;

	// calculate forward bearing of path at start point
	_bearingY = Sin ( _longitudeDifference ) * _cosLatitudeDifference ;
	_bearingX =
		_cosStartLatitude * _sinEndLatitude
		- _sinStartLatitude * _cosEndLatitude * _cosLongitudeDifference ;
	_startBearing =	// Atan2 ( _bearingY ; _bearingX ) in range [0,2*Pi)
		Case (
			_bearingX < 0 ;
				Atan ( _bearingY / _bearingX ) + Pi ;

			_bearingX > 0 and _bearingY < 0 ;
				Atan ( _bearingY / _bearingX ) + 2 * Pi ;

			_bearingX ≠ 0 ;
				Atan ( _bearingY / _bearingX ) ;

			_bearingY > 0 ;
				Pi / 2 ;

			_bearingY < 0 ;
				3 / 2 * Pi ;

			/* Else, _bearingX = _bearingY = 0 */
				0
		) ;

	// calculate forward bearing of path at end point
	// evaluate as bearing from end point to start point, then reverse direction
	_longitudeDifference = 0 - _longitudeDifference ;
	_bearingY =
		Sin ( _longitudeDifference )
		* Cos ( _startLatitude - _endLatitude ) ;
	_bearingX =
		_cosEndLatitude * _sinStartLatitude
		- _sinEndLatitude * _cosStartLatitude * Cos ( _longitudeDifference ) ;
	_endBearing =	// Atan2 ( _bearingY ; _bearingX ) in range [0,2*Pi)
		Case (
			_bearingX < 0 ;
				Atan ( _bearingY / _bearingX ) + Pi ;

			_bearingX > 0 and _bearingY < 0 ;
				Atan ( _bearingY / _bearingX ) + 2 * Pi ;

			_bearingX ≠ 0 ;
				Atan ( _bearingY / _bearingX ) ;

			_bearingY > 0 ;
				Pi / 2 ;

			_bearingY < 0 ;
				3 / 2 * Pi ;

			/* Else, _bearingX = _bearingY = 0 */
				0
		) ;
	_endBearing =	// reverse direction for forward azimuth
		Mod ( Degrees ( _endBearing ) + 180 ; 360 )
] ;
	_distance
	& ¶
	& Degrees ( _startBearing )
	& ¶
	& _endBearing
)