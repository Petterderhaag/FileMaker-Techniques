/*******************************************************************************
 * LocationEndPoint ( startLatitude ; startLongitude ; azimuth ; distanceInMeters )
 * Calculates the latitude and longitude for the end location of a path on the
 * surface of the Earth based on the starting location, direction, and distance.
 *
 * @parameter startLatitude: Latitude of the start point, in degrees
 * @parameter startLongitude: Longitude of the start point, in degrees
 * @parameter azimuth: The direction at the start of the path, in degrees
 * clockwise from due north in [0,360)
 * @parameter distanceInMeters: The length of the path, in meters
 *
 * @return A return-delimited list of data about the destination point of the
 * path:
 *		1. latitude of the destination point
 *		2. longitude of the destination point
 *		3. forward azimuth of the path at the destination
 *
 * @history 2014-09-15 - Jeremy Bante <http://scr.im/jbante> - Created
 * @history 2015-04-09 - Jeremy Bante <http://scr.im/jbante> - Corrected
 * calculations
 *
 * @see http://www.dtic.mil/dtic/tr/fulltext/u2/703541.pdf
 * @see http://en.wikipedia.org/wiki/World_Geodetic_System
 ******************************************************************************/

If ( azimuth > 180 ;
	// the calculation assumes west direction, so reverse inputs and result
	Let ( [
		_values =
			LocationEndPoint (
				0 - startLatitude ;
				0 - startLongitude ;
				azimuth - 180 ;
				distanceInMeters
			)
	] ;
		List (
			0 - GetValue ( _values ; 1 ) ;
			0 - GetValue ( _values ; 2 ) ;
			Mod ( GetValue ( _values ; 3 ) + 180 ; 360 )
		)
	) ;

/* Else */
	Let ( [
		_equatorialRadius = 6378137 ;	// meters
		_flattening = .0033528106647475 ;	// 1 / 298.257223563
		_oneMinusFlattening = 1 - _flattening ;

		_tanPhi1 = Tan ( Radians ( startLatitude ) ) ;
		_tanTheta1 = _oneMinusFlattening * _tanPhi1 ;
		_theta1 = Atan ( _tanTheta1 ) ;
		_sinTheta1 = Sin ( _theta1 ) ;
		_cosTheta1 = Cos ( _theta1 ) ;

		_azimuth = Radians ( azimuth ) ;
		_sinAzimuth = Sin ( _azimuth ) ;
		_cosAzimuth = Cos ( _azimuth ) ;
		_mm = _cosTheta1 * _sinAzimuth ;
		_nn = _cosTheta1 * _cosAzimuth ;

		_c1 = _flattening * _mm ;
		_c2 = .25 * ( 1 - _mm ^ 2 ) * _flattening ;
		_dd = ( 1 - _c2 ) * ( 1 - _c2 - _c1 * _mm ) ;
		_pp = _c2 * ( 1 + .5 * _c1 * _mm ) / _dd ;

		_sigma1 = Acos ( _sinTheta1 / Sin ( Acos ( _mm ) ) ) ;
		_d = distanceInMeters / ( _equatorialRadius * _dd ) ;
		_sin_d = Sin ( _d ) ;
		_cos_d = Cos ( _d ) ;
		_u = 2 * ( _sigma1 - _d ) ;
		_cos_u = Cos ( _u ) ;

		_vv = _cos_u * _cos_d - Sin ( _u ) * _sin_d ;
		_deltaSigma =
			_d
			+ _c2 ^ 2 * _sin_d * _cos_d * ( 2 * _vv ^ 2 - 1 )
			- 2 * _pp * _vv * ( 1 - 2 * _pp * _cos_u ) * _sin_d ;
		_sinDeltaSigma = Sin ( _deltaSigma ) ;
		_cosDeltaSigma = Cos ( _deltaSigma ) ;

		_alpha21 =
			If ( _mm ≠ 0 ;
				Mod (
					Atan (
						_mm
						/ ( _nn * _cosDeltaSigma - _sinTheta1 * _sinDeltaSigma )
					) ;
					Pi
				) + Pi ;	// in [Pi,2*Pi)
			/* Else */
				0
			) ;

		_tanPhi2 =
			If ( _mm ≠ 0 ;
				-1
				* ( _sinTheta1 * _cosDeltaSigma + _nn * _sinDeltaSigma )
				* Sin ( _alpha21 )
				/ ( _oneMinusFlattening * _mm ) ;
			/* Else */
				Tan ( Pi / 2 + _sigma1 - _deltaSigma ) / _oneMinusFlattening
			) ;
		_phi2 = Atan ( _tanPhi2 ) ;

		_hh =
			_c1 * ( 1 - _c2 ) * _deltaSigma
			- _c1 * _c2 * _sinDeltaSigma * Cos ( 2 * _sigma1 - _deltaSigma ) ;
		_tanDeltaEta =
			_sinDeltaSigma * _sinAzimuth
			/ (
				_cosTheta1 * _cosDeltaSigma
				- _sinTheta1 * _sinDeltaSigma * _cosAzimuth
			) ;
		_v = Atan ( Abs ( _tanDeltaEta ) ) ;
		_deltaEta =
			If ( _tanDeltaEta ≤ 0 or _v < _hh ; Pi - _v ; /* Else */ _v ) ;
		_deltaLambda = _deltaEta - _hh ;
		_lambda2 = Radians ( startLongitude ) + _deltaLambda ;
		_lambda2 =
			If ( _lambda2 > Pi ; _lambda2 - 2 * Pi ; /* Else */ _lambda2 )
	] ;
		List (
			Degrees ( _phi2 ) ;
			Degrees ( _lambda2 ) ;
			Degrees ( _alpha21 )
		)

	)
)