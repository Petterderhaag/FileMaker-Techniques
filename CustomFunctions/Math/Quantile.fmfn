/*******************************************************************************
 * Quantile ( numberList ; theQuantile )
 * Finds a quantile of a list of numbers, i.e., the value in numberList such
 * that ValueCount ( numberList ) * theQuantile values of numberList are less
 * than that value.
 *
 * @parameter numberList: a return-delimited list of numbers
 * @parameter theQuantile: a number, 0 < theQuantile < 1
 *
 * @return A value from numberList
 *
 * @history 2011-05-16 - Jeremy Bante <http://scr.im/fugue> - Created
 * @history 2016-12-14 - Jeremy Bante <http-//scr.im/fugue> - Improving speed
 * by using the Quickselect algorithm.
 *
 * @see https://en.wikipedia.org/wiki/Quickselect
 ******************************************************************************/

 Case (
	/* Step 0, select pivot */
	not $~step ;
		Let ( [
			$~n = ValueCount ( numberList ) ;
			_pivotPosition =
				If ( $~n < 3 ;
					1 ;
					/* Else */ Ceiling ( $~n * ( theQuantile + 1 - Random ) / 2 )
				) ;
			// For short lists, choosing the first value for the pivot and
			// reversing the list order in the partitions guarantees that the
			// same pivot will not be selected twice in a row, leading to
			// degenerate recursion. Otherwise, using the mean of theQuantile
			// and a random value is a compromise between probabilistically
			// optimum speed on random lists and best speed when the numberList
			// is already (more-or-less) sorted.
			$~pivot = GetAsNumber ( GetValue ( numberList ; _pivotPosition ) ) ;
			_firstValue = LeftValues ( numberList ; 1 ) ;
			$~number = GetAsNumber ( _firstValue ) ;
			$~step =
				Case (
					theQuantile ≤ 0 or theQuantile ≥ 1 ;	-1 ;	// bad input
					$~n < 2 ;	2 ;	// solution is trivial
					/* Else */ 1
				)
		] ;
			Quantile (
				Replace ( numberList ; 1 ; Length ( _firstValue ) ; "" ) ;
				theQuantile
			)
		) ;

	/* Step 1, partition numberList according to pivot */
	$~step = 1 and ( $~number = $~pivot or IsEmpty ( $~number ) ) ;
		Let ( [
			// Having this separate case prevents a degenerate scenario of a
			// list where all values are equal
			_nextValue = LeftValues ( numberList ; 1 ) ;
			$~number = GetAsNumber ( _nextValue ) ;
			$~i = $~i + 1 ;
			$~step = If ( $~i < $~n ; $~step ; /* Else */ $~step + 1 )
		] ;
			Quantile (
				Replace ( numberList ; 1 ; Length ( _nextValue ) ; "" ) ;
				theQuantile
			)
		) ;

	$~step = 1 and $~number < $~pivot ;
		Let ( [
			$~lowList = List ( $~number ; $~lowList ) ;
			// Reversing the order in partitions is part of a strategy to avoid
			// degenerate recursion in small lists, and also part of a strategy
			// to balance good speed between lists already (more-or-less) sorted
			// ascending vs. descending (in combination with pivot selection).
			$~lowN = $~lowN + 1 ;
			_nextValue = LeftValues ( numberList ; 1 ) ;
			$~number = GetAsNumber ( _nextValue ) ;
			$~i = $~i + 1 ;
			$~step = If ( $~i < $~n ; $~step ; /* Else */ $~step + 1 )
		] ;
			Quantile (
				Replace ( numberList ; 1 ; Length ( _nextValue ) ; "" ) ;
				theQuantile
			)
		) ;

	$~step = 1 ; // and $~number > $~pivot
		Let ( [
			$~highList = List ( $~number ; $~highList ) ;
			$~highN = $~highN + 1 ;
			_nextValue = LeftValues ( numberList ; 1 ) ;
			$~number = GetAsNumber ( _nextValue ) ;
			$~i = $~i + 1 ;
			$~step = If ( $~i < $~n ; $~step ; /* Else */ $~step + 1 )
		] ;
			Quantile (
				Replace ( numberList ; 1 ; Length ( _nextValue ) ; "" ) ;
				theQuantile
			)
		) ;

	/* Step 2, recurse on partition, or return result */
	$~step = 2 or $~step = -1 ;
		Let ( [
			// setup next partition
			_lowSize = $~lowN / $~n ;
			_highSize = $~highN / $~n ;
			_useLowList = _lowSize > theQuantile ;
			_useHighList = _highSize ≥ 1 - theQuantile ;
			_newList =
				Case (
					_useLowList ;	$~lowList ;
					_useHighList ;	$~highList
				) ;
			_newQuantile =
				Case (
					_useLowList ;
						theQuantile  / _lowSize ;
					_useHighList ;
						Max (
							( theQuantile - 1 + _highSize ) / _highSize ;
							1 / ( $~highN + 1 )
						)
				) ;

			// check for completion
			_error = $~step = -1 ;
			_listIsEmpty = $~n = 0 ;
			_result =
				Case (
					not ( _useLowList or _useHighList ) ;	$~pivot ;
					_useLowList and $~lowN = 1 ;	$~lowList ;
					_useHighList and $~highN = 1 ;	$~highList ;
					/* Else */	""
				) ;

			// purge variables
			$~highList = "" ;
			$~highN = "" ;
			$~i = "" ;
			$~lowList = "" ;
			$~lowN = "" ;
			$~n = "" ;
			$~number = "" ;
			$~pivot = "" ;
			$~step = ""
		] ;
			Case (
				_error ;	"?" ;
				not IsEmpty ( _result ) or _listIsEmpty ;	_result ;
				/* Else */	Quantile ( _newList ; _newQuantile )
			)
		)
)