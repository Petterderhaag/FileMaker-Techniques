/**
 * =====================================
 * Bezier ( t ; controlPoints )
 *
 * PURPOSE:
 * Calculates the value at t of the Bézier curve defined by the specified
 * controlPoints.
 *
 * RETURNS:
 * A number representing the point on the Bézier curve defined by the given
 * controlPoints at value t.
 *
 * PARAMETERS:
 * t: A number, 0 ≤ t ≤ 1
 * controlPoints: A ¶-delimited list of numbers, where the first value is the
 * starting point, and the last value is the ending point of the curve.
 *
 * DEPENDENCIES: none
 *
 * HISTORY:
 * CREATED on 2011-01-26 by Jeremy Bante of The Support Group
 * <http://scr.im/jbante>.
 *
 * REFERENCES:
 * http://en.wikipedia.org/wiki/B%C3%A9zier_curve
 * =====================================
 */

Case (
	/*Step 0, initialize with linear Bézier curve*/
	not $~step;
	Let ( [
		$~n = ValueCount ( controlPoints ) - 1;
		$~i = 0;
		$~sum = ( 1 - t ) * GetValue ( controlPoints ; $~i + 1 );
		$~step =
			Case (
				t < 0 or t > 1 ; 2; //error, out of range
				$~i ≥ $~n; 3; //trivial case, skip to return result
				/*else*/ 1
			)
	];
		Bezier ( t ; controlPoints )
	);

	/*Step 1, add-up sum for arbitrary-degree Bézier curve*/
	$~step = 1;
	Let ( [
		$~i = $~i + 1;
		$~sum =
			$~sum
			+ Combination ( $~n ; $~i )
			* ( 1 - t ) ^ ( $~n - $~i )
			* t ^ ( $~i )
			* GetValue ( controlPoints ; $~i + 1 );
		$~step = If ( $~i ≥ $~n ; 3 ; /*else*/ $~step )
	];
		Bezier ( t ; controlPoints )
	);

	/*Step 2, handle errors*/
	$~step = 2;
	Let ( [
		$~sum = "?";
		$~step = $~step + 1
	];
		Bezier ( "" ; "" )
	);

	/*Step 3, clean-up and return result*/
	$~step = 3;
	Let ( [
		~sum = $~sum;

		//purge variables
		$~i = "";
		$~n = "";
		$~step = "";
		$~sum = ""
	];
		~sum
	)
)